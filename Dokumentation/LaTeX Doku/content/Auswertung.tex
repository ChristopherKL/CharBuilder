\newpage
\section{Einleitung}
In diesem Dokument wird die Entwicklung der Applikation CharBuilder als Semesterprojekt für das Wahlpflichtfach Mobile Applikationen dargestellt. Die Aufgabenstellung hat uns sowohl die Wahl der Plattform als auch die Art der App offengelassen. Da wir in der Vorlesung die Grundlagen der App-Entwicklung unter Android gelernt haben, machte es für uns Sinn, unsere erste App für Android zu entwickeln. Weitere Faktoren für die Entscheidung waren, dass man für die Entwicklung keinen teuren Development Account benötigt und beide Entwickler bereits Kenntnisse in Java besitzen. Außerdem kann die App direkt auf dem eigenen Smartphone getestet werden.\\

Die Idee der App entstand aus unserem gemeinsamen Hobby, dem Pen and Paper Rollenspiel. Pen and Apper Charaktere werden normalersweise am Computer generiert und verwaltet. Wenn man sich zum Spielen trifft, bringt jeder seinen Charakterbogen ausgedruckt oder als Datei auf dem Handy mit. Ziel der App ist es, Charaktere auf dem Handy erstellen und verwalten zu können. Dadurch kann man sich das Ausdrucken oder Übertragen aufs Handy sparen und muss es nur noch mitnehmen.\\

Der Aufgabenstellung konnten wir die fünf Themengebiete Stand der Technik, Anforderungen, Architektur, Implementierung und Test und Usability für unsere Dokumentation entnehmen. Auf jedes dieser Themen werden wir im Laufe des Dokuments eingehen und dadurch strukturiert die Entwicklung der App aufzeigen.

\newpage
\section{Stand der Technik}
Im Nachfolgenden wird erläutert, welche Technologien wir für die Erstellung der CharBuilder App verwendeten und warum diese von uns gewählt wurden. Hierbei haben wir den Text in die Unterkategorien Android(Betriebssystem), Kotlin(Programmiersprache), Gson(Json Java-Lib), Gradle(Build Tool), Android Studio(IDEA) und UMLet(UML Tool) aufgeteilt. Das sind die wichtigsten Technologien, die wir zum Entwickeln unserer App genutzt haben.

\subsection{Android}
Wie in der Einleitung geschrieben, haben wir uns für Android als Betriebssystem entschieden. Da verschiedene Version dessen auf unterschiedlichen Geräten verteilt sind
muss man sich als Entwickler darüber hinaus auch für ein Mindest-API-Level entscheiden. Dies stellt die niedrigste Android Version dar, unter welcher die App ausgeführt werden kann.
Bei der Wahl des API-Levels spielen verschiedene Faktoren eine Rolle, unter anderem wie viele der Android Geräte welche Version des Betriebssystems ausführen oder ob der Entwickler
Funktionen nutzen möchte die erst ab einer bestimmten Version verfügbar sind.\\
%includegraphics("bild api verteilung android")
Wir haben uns entschieden, unsere Applikation lediglich für Android Betriebssysteme der Version 5.0(API Level 21) oder höher zu entwickeln.
Die Version 5 ist bereits am 12.11.2014 veröffentlicht worden und bringt einen großen Wandel in der Benutzeroberfläche durch Googles Material Design.
Dieses ist an den Gestaltungsstil "Flat Design" angelehnt und minimalistisch gehalten. Die Entscheidung trafen wir aufgrund der weitreichenden 
Änderungen in dieser Version, des bereits 3 Jahre in der Vergangenheit liegenden Veröffentlichungsdatums und der breiten Verteilung von 80,7\% aller Android Geräte.
%\cite{https://de.statista.com/statistik/daten/studie/180113/umfrage/anteil-der-verschiedenen-android-versionen-auf-geraeten-mit-android-os/}.\\

\subsection{Kotlin}

Kotlin ist eine neue Programmiersprache von JetBrains aus dem Jahr 2016. Wie auch Java kompiliert Kotlin zu JVM Bytecode. Es lässt sich dadurch sehr gut in das bestehende Java Ökosystem einbinden und kann alle Java Bibliotheken verwenden. Seit dem 17. Mai 2017 ist Kotlin eine von Android offiziel unterstützte Sprache.\\
%\cite{https://10clouds.com/blog/kotlin-android/}
Beide Teammitglieder haben zuvor noch nicht mit Kotlin gearbeitet, konnten sich jedoch aufgrund der Ähnlichkeit zu Java schnell zurechtfinden und gute Erfahrungen sammeln. Die Programmiersprache bietet dem Programmierer viele Vorteile wodurch sie immer beliebter wird unter Androidentwicklern. Der weitreichenste Vorteil ist es  null-Referenzen zu verhindern, die Sprache bietet einem "Null Safety". Eine weitere Änderung ist auch die Möglichkeit Datenklassen zu erstellen, diese sind Klassen welche lediglich Daten halten und keinerlei Methoden selbst implementieren. Ein Beispiel dieser kann man im Kapitel Implementierung finden. Der Großteil der Appentwicklung geschah mit Kotlin v1.15 später wurde dann ein Update auf Kotlin v1.2 durchgeführt. Dies liegt an dem Entwicklungszyklus von Kotlin, so wurde immer mit dem aktuellsten stabilen Release gearbeitet.
%include graphics(kotlin findviewbyid bild christopher)
%\cite{https://kotlinlang.org/}

\subsection{Gson}

Gson ist eine Java Bibliothek zur Serialization und Deserialization. Sie wird genutzt um Java Objekte in JSON umzuwandeln oder auch JSON zu Java Objekten zu wandeln. Hierbei ist die Möglichkeit Generics zu verwenden äußerst wichtig, da diese in der CharBuilder Applikation mehrmals zum Einsatz kommt. Wir haben diese Bibliothek ausgesucht da sie uns bereits bekannt war von früheren Projekten und wir positive Erfahrungen gemacht haben. Desweiteren wird die Software bereits seit 2008 entwickelt und konnte seitdem durch viele Revisionen und Verbesserungen überzeugen. Für die App verwendet wir die Gson Version 2.8.2.
%\cite{https://github.com/google/gson}

\subsection{Gradle}

Gradle ist ein weit verbreitetes Build-Tool, welches automatisiert arbeitet und Unterstützung für mehrere verschiedene Sprachen bietet. Es wird typischerweise für Android Applikationen verwendet, welche mit Android Studio entwickelt werden, da das Tool tief in die Entwicklungsumgebung integriert ist. Zu unserer Entscheidung dieses Programm zu verwenden kann nicht viel gesagt werden, da es wie oben erwähnt bereits integriert war und eine Alternative neben großem Mehraufwand keine Vorzüge geboten hätte.

\subsection{Android Studio}

Android Studio ist die offizielle Entwicklungsumgebung für native Androidprogrammierung. Es bietet neben den bekannten IDE Funktionen wie Syntax Highlighting, Autovervollständigung, Instant Run(Es wird nur der veränderte Teil neu kompiliert) und Debugger auch einen Android Emulator, um verschiede Geräte und Android Version zu simulieren. Die IDE basiert auf IntelliJ's Softwareprodukten. Mit der Version 3.0.1 wurde die Entwicklungsumgebung für Kotlin angepasst, dies ist auch die Version welche wir zur Entwicklung unserer App verwendeten. Dabei liefert die neue Version ebenfalls ein Programm, um Java-Code direkt in Kotlin-Code umzuwandeln.  Dem Entwickler wird so der Einstieg in Kotlin erleichtert, das Tool sollte im späteren Verlauf aber nur selten genutzt werden, um eine einheitliche Codequalität zu erreichen.

\subsection{UMLet}

UMLet ist ein kostenloses Open-Source UML Tool mit einer simplen Benutzeroberfläche. Die erstellten Diagramme lassen sich z.B. als pdf, jpg oder png exportieren. Wenn einem die große Auswahl an UML Elementen nicht reicht, kann man eigene erstellen oder importieren. Zum Zeichnen unserer Diagramme haben wir die Version 14.2 genutzt. %\cite{http://www.umlet.com/}

\newpage
\section{Anforderungen}
Im folgenden Kapitel werden die Anforderungen, die wir an unsere App gestellt haben, genauer beschrieben. Diese Anforderungen wurden von uns vor Beginn der App-Implementierung aufgestellt, um einen Überblick über alle Funktionen zu erhalten, die die App beinhalten wird. Die Anforderungen sind in diese vier Kategorien eingeteilt:
\begin{description}
\item[Must Have]\hfill \\
Unter \grqq Must have\grqq{} ist jede Funktionalität aufgelistet welche \textbf{unbedingt} umgesetzt werden muss, um das Projekt als erfolgreich bezeichnen zu können. Diese Kategorie wird oft auch \grqq Minimale Anforderungen\grqq{} genannt.
\item[Should Have]\hfill \\
Die Kategorie \grqq Should have\grqq{} fasst all die Punkte unter sich zusammen, die für ein erfolgreiches Projekt nicht unbedingt erforderlich sind, aber dennoch wichtiger Bestandteil sein können. Als Beispiel sei eine Funktionalität zu sehen, welche das Produkt lediglich erweitert, von welcher die Grundfunktionalitäten allerdings nicht abhängig sind.
\item [Could Have]\hfill \\
Features, die unter \grqq Could have\grqq{} aufgelistet sind, werden nur umgesetzt, wenn alle Punkte unter \grqq Must have\grqq{} und \grqq Should have\grqq{} bereits abgearbeitet sind. Sie sind vollkommen optional.
\item[Won't Have]\hfill \\
\grqq Won't have\grqq{} beinhaltet jene Punkte, welche \textbf{nicht} umgesetzt werden. Sie wurden von den Entwicklern oder Auftraggebern zu Beginn der Projektspezifikation ausgeschlossen.
\end{description}

\subsection{Must Have}
Als wichtigste Funktion der App gilt das Erstellen eines neuen Charakters. Es muss möglich sein einen Charakter entsprechend des gewählten Regelwerks zu erstellen. Zunächst wird es nur möglich sein Charaktere im Regelwerk \textit{Star Wars: Am Rande des Imperiums} zu erschaffen. Während des Erstellungsprozesses kann der Nutzer auf Regeltexte zurückgreifen, die ihm seine aktuellen Auswahlmöglichkeiten erklären. Diese Regeltexte werden aufgrund von eventuellen Urheberrechtsverletzungen nicht aus dem offiziellen Regelwerk kopiert, sondern von den Entwicklern der App zusammengefasst.\\

Nachdem der Nutzer einen Charakter erstellt hat, wird dieser in einer Liste mit anderen bereits von ihm angelegten Charakteren angezeigt. In der Liste wird das für den Charakter ausgewählte Bild, sein Name und das Regelwerk, in dem er gespielt wird, dargestellt. Der Nutzer kann nicht mehr benötigte Einträge aus der Liste löschen, Änderungen an den Charakteren vornehmen und diese als PDF-Datei exportieren. Durch einen Klick auf einen der Listeneinträge werden dem Nutzer alle Eigenschaften, Talente, Spezialisierungen, etc. zu einem Charakter angezeigt.\\

Eine weitere Funktion der App ist das eingebaute Würfeltool. Wenn der Nutzer sich in der Detailansicht zu einem seiner Charaktere befindet, kann er ohne großen Aufwand Proben auf seine Fähigkeiten werfen. Es wird dann berechnet, ob die Probe erfolgreich war oder nicht und das Ergebnis erscheint in einem Dialog. Außerdem wird das Ergebnis des Würfelwurfs im Verlauf des Würfeltools angezeigt, sodass der Nutzer eine Übersicht seiner vorherigen Proben erhält. Das Würfeltool ist über die Navigationsleiste im Hauptmenü erreichbar und bietet eine Auswahl an Würfeln, die für das jeweilige Regelwerk benötigt werden.

\subsection{Should Have}
Damit Charaktere nicht an ein bestimmtes Gerät gebunden sind, sollte der Nutzer die Möglichkeit haben, seine Charakterdaten als JSON-Datei in Google Drive zu speichern. Jeder Charakter bereist im Zuge seiner erlebten Abenteuer eine Vielzahl von Orten. Um dem Spieler eine Erinnerungsstütze zu geben, an welchen Orten sein Charakter schon war und was für Abenteuer er dabei abgeschlossen hat, sollte es eine Art Reisetagebuch für jeden Charakter geben.

\subsection{Could Have}
Es wird nicht ausgeschlossen, dass die App die Erstellung von Charakteren in unterschiedlichen Regelwerken ermöglicht. Allerdings gibt es große Unterschiede in der Komplexität und dem Umfang von Pen and Paper Regelwerken, weswegen zunächst nur ein Regelwerk unterstützt wird. Eine englischsprachige Version der App ist geplant. Das Übersetzen der Regeln nimmt jedoch viel Zeit in Anspruch. Eine weitere mögliche Option wäre das Einbinden der Google Billing API, die dem Entwickler das Freischalten von In-App Käufen ermöglicht.

\subsection{Won't Have}
Die App wird keine Gruppenverwaltung ermöglichen. Das bedeutet, dass ein Spielleiter nicht die Charaktere seiner Gruppenmitglieder einsehen kann. Außerdem werden in der App keine spielbaren Abenteuer vorhanden sein. Sie dient lediglich dem Speichern und Verwalten von Pen and Paper Charakteren. Nutzer der App werden in der App keine Anleitung für das Spielen von Pen and Paper Abenteuern finden. Alle verwendeten Auszüge aus Regelwerken dienen ausschließlich der Unterstützung während des Erstellungsprozesses. 

\newpage
WIP
\subsection{Idee}

Die App stellt einen digitalen Pen und Paper Charakterbogen dar. Es wird möglich sein, neue Charaktere anzulegen und die bereits bestehenden zu verwalten. Der Nutzer soll außerdem die Möglichkeit haben, seine Charaktere auf andere Geräte zu übertragen. Zu Beginn werden wir uns auf das \glqq Star Wars : Am Rande des Imperiums\grqq- Regelwerk konzentrieren.

\section{Architektur}
\subsection{Model View Controller(MVC)}
CharCreationController als Controller, Player als Model, Fragmente als View

\newpage
\section{Implementierung}

\subsection{Charaktererstellung}
Da die Erstellung eines Charakters im offiziellen Regelwerk bereits in sinnvolle Schritte unterteilt war, wollten wir diese Gliederung in der App wiederspiegeln. Durch das Bewahren der in den Regeln eingeführten Struktur haben neue Spieler einen guten Überblick über die für die Charaktererstellung benötigten Schritte. Außerdem müssen sich Spieler, die das offizielle Regelwerk bereits kennen, nicht an eine neue Gliederung gewöhnen. In der App werden die Schritte durch Fragmente dargestellt. Jedes Fragment besitzt ein eigenes Layout, das an die Anforderungen des jeweiligen Erstellungsschritts angepasst ist. Für die Navigation zwischen den einzelnen Fragmenten verwenden wir ein \textit{TabLayout}. Dieses Layout wird durch die Klasse \textit{CharCreationController} mit den nötigen Tabs versehen.\\

Der \textit{CharCreationController} ist eine Activity, die geöffnet wird, sobald der Nutzer die Charaktererstellung startet. Er besitzt eine innere Klasse namens \textit{PageAdapter}, welcher von der durch Android zu Verfügung gestellten Klasse \textit{FragmentStatePagerAdapter} erbt. Durch den \textit{PageAdapter} wird geregelt, wann ein neues Fragment geladen wird und an welcher Stelle des \textit{TabLayouts} dieses Fragment eingeordnet wird. Das \textit{TabLayout} bietet dem Nutzer eine gute Übersicht über die Schritte der Charaktererstellung. Durch Klicken auf die Namen der einzelnen Tabs oder das Wischen nach links oder rechts kann der Nutzer frei wählen, welche Schritte des Erstellungsprozesses er bearbeiten möchte. Zudem kann er nachträglich Änderungen an Fragmenten vornehmen, falls ihm seine derzeitige Wahl nicht gefällt.\\

Jede Eingabe, die der Nutzer während der Erstellung in den Fragmenten einträgt, wird an die Activity weitergegeben, welche die Daten in einer Instanz der Klasse \textit{Player} speichert. Bei Initialisierung eines neuen Fragments wird geprüft, ob schon Werte in den entsprechenden Attributen des Player-Objekts vorhanden sind. Hat der Nutzer das geladene Fragment schonmal bearbeitet und möchte jetzt Änderungen vornehmen, sollen die Felder wieder so ausgefüllt sein, wie er sie hinterlassen hat. Eine weitere potenzielle Quelle für Verlust von Daten ist das versehentliche Drücken der Zurück-Taste auf der \textit{Android Navigation Bar}. Zur Vermeidung dieses Problems fängt die Activity Klicks auf die Zurück-Taste ab und zeigt einen Dialog an, in dem man das Abbrechen der Charaktererstellung bestätigen muss.\\

Es gibt zwei Layouts, die in mehreren Fragmenten als Listenelement in \textit{ListViews} oder als Group Item in \textit{ExpandableListViews} eingesetzt werden:
\begin{description}
\item[char\_creation\_listview.xml]\mbox{}\\
Ein Layout bestehend aus zwei \textit{TextViews} für Name und kurz Beschreibung des jeweiligen Elements und einem anklickbaren \textit{ImageView}, das, wenn der Nutzer darauf drückt, einen Dialog mit dem Regeltext zum jeweiligen Element wiedergibt.
\item[char\_creation\_career\_group\_item.xml]\mbox{}\\
Dieses Layout besteht nur aus einem \textit{TextView} und wird in \textit{ExpandableListViews} als Group Item Layout verwendet.
\end{description}

Einige der Fragmente verfügen über eine \textit{Data Class}. Diese Klassen sind ein in Kotlin eingeführtes Konzept, um das Schreiben von unnötigem \grqq Boilerplate Code\grqq{} in einfachen Klassen, die nur als Datencontainer genutzt werden, zu verhindern \cite{dataclasses}. Häufig werden die Datenklassen in den Fragmenten dazu genutzt, Daten aus einer geparsten XML-Datei zu speichern und sie dann in ein \textit{ListView}-Element zu laden. Mit Hilfe dieser Methode erleichtern wir uns das Zuordnen der passenden Kurzbeschreibungen und Regeltexte zu einem entsprechenden Regelbegriff.\\

Im Folgenden werden wir auf die einzelnen Fragmente und ihre Funktionen eingehen.

\subsubsection{ObligationFragment.kt}
Der erste Schritt in einer Charaktererstellung ist das Bestimmen der Verpflichtung/en eines Charakters. Das Regelwerk zu \glqq Star Wars : Am Rande des Imperiums\grqq{} \cite[39]{rulebook} gibt eine Liste von zwölf wählbaren Pflichten vor. Dem Spieler werden zwei Möglichkeiten angeboten, eine Pflicht für seinen Charakter zu wählen:
\begin{enumerate}
\item Der Spieler sucht sich aus der Liste mit zwölf Einträgen eine für ihn passende Pflicht aus.
\item Durch das Drücken auf einen Button lässt der Spieler die App per Zufall ein oder zwei Pflichten bestimmen.
\end{enumerate}

Zur Umsetzung der Liste haben wir uns für eine \textit{ListView} entschieden, die durch die innere Klasse \textit{ObligationsViewAdapter} mit Inhalt gefüllt wird. Der \textit{ObligationsViewAdapter} ist eine Unterklasse des \textit{BaseAdapters} aus der Android API, welcher in der \textit{onCreateView}-Methode des Fragments als Adapter der \textit{ListView} gesetzt wird. Mit der Liste aus Pflichten, die zuvor aus einer XML-Datei geparst wurde, erstellt der Adapter dann jedes Listenelement anhand des Layouts aus der \textit{char\_creation\_listview.xml}. Nachdem ein Listenelement angeklickt wurde, wird es blau hinterlegt und der Name der Pflicht wird als aktuell ausgewählte Pflicht im oberen Textfeld angezeigt.\\

Jede Pflicht hat eine Wahrscheinlichkeit von 8\% durch den Zufall ausgewählt zu werden. Insgesamt hat der Spieler also eine Chance von 96\% nur eine Pflicht bei der zufälligen Bestimmung zu erhalten. Die übrigen 4\% bilden die Wahrscheinlichkeit dafür, dass der Charakter mit zwei Pflichten startet. Diese Warscheinlichkeiten für das Auswählen der Pflichten wurden dem Regelwerk \cite[39]{rulebook} entnommen, das eine Tabelle mit Würfelergebnissen für jede Verpflichtung beinhaltet. Während der Erstellung ist die Zufallsbestimmung der einzige Weg, eine zweite Verpflichtung zu erhalten. Aus diesem Grund musste in der Implementierung darauf geachtet werden, dass das Textfeld der zweiten Pflicht zurückgesetzt wird, wenn eine neue ausgewählt wird. Dabei ist es egal, ob die neue Verpflichtung durch den Spieler oder den Zufall gesetzt wird. Wenn die derzeitige Pflicht dem Spieler nicht gefällt, kann er sie beliebig oft selbst ändern oder durch Drücken des Buttons neu bestimmen. Die Reihenfolge der Aktionen spielt dabei keine Rolle.\\

\subsubsection{SpeciesFragment.kt}
\subsubsection{CareerFragment.kt}
\subsubsection{SpecializationFragment.kt}
\subsubsection{AttributeFragment.kt}
\subsubsection{ExperienceFragment.kt}

\subsubsection{MotivationFragment.kt}
In diesem Schritt der Charaktererstellung wählt der Spieler die Motivation des Charakters aus. Es gibt insgesamt 30 Motivationen, die in drei Oberkategorien mit jeweils zehn Motivationen eingeteilt sind. Wie auch im \textit{ObligationFragment} hat der Spieler zwei Möglichkeiten zur Auswahl:
\begin{enumerate}
\item Der Spieler sucht sich aus den drei Oberkategorien mit insgesamt 30 Einträgen eine für ihn passende Motivation aus.
\item Die App bestimmt durch Drücken eines Buttons per Zufall ein oder zwei Motivationen.
\end{enumerate}

Zur Umsetzung der Listen mit den drei Oberkategorien nutzen wir eine \textit{ExpandableListView}, da sie genau die Eigenschaften mitbringt, die für so eine Darstellung nötig sind. Wenn der Nutzer zu diesem Fragment wechselt, sieht er zunächst nur die drei Oberkategorien Zielsetzung, Beweggrund und Bindung. Diese Group Items besitzen das Layout der \textit{char\_creation\_career\_group\_item.xml}, welches ihnen durch den \textit{MotivationListAdapter} zugeteilt wird. Als Unterklasse des \textit{BaseExpandableListAdapters} wird der \textit{MotivationListAdapater} in der \textit{onCreateView}-Methode des Fragments als Adapter der \textit{ExpandableListView} eingesetzt. Klickt der Nutzer auf ein Group Item, wird die Liste mit den zugehörigen Motivationen entfaltet. Das Layout der Child Items ist wiedermal die \textit{char\_creation\_listview.xml}.\\

Da die Motivationen in drei Kategorien eingeteilt sind, verlief die Bestimmung der Motivationen per Zufall etwas anders als im \textit{ObligationFragment}. Zunächst wurden anhand einer Tabelle im Regelwerk \cite[94]{rulebook} die Wahrscheinlichkeiten der Oberkategorien entnommen. Die Tabelle gibt für jede der Kategorien eine Wahrscheinlichkeit von 30\% an. Die übrigen 10\% geben die Chance wieder, bei der Erstellung eine zweite Motivation zu bekommen. Tritt dieser Fall ein, müssen zwei Kategorien ausgewürfelt werden. Nachdem eine oder zwei Kategorien bestimmt wurden, aus denen eine Motivation gewählt wird, erfolgt ein erneuter Zufallswurf. Für diese Zufallsbestimmung liegt die Wahrscheinlichkeit für alle Motivationen der jeweiligen Gruppe bei 10\%. Auch in diesem Fragment gilt die Zufallsbestimmung als einzige Möglichkeit, eine zweite Motivation zu erhalten. Beim Klicken auf ein Child Item oder das erneute Drücken des Zufallsbuttons wird das Feld für die zweite Motivation zurückgesetzt.\\

Die \textit{ExpandableListView} war nicht unsere erste Wahl zur Dartstellung der Motivationen. Das ursprüngliche Layout des Fragments bestand aus drei untereinander angeordneten \textit{ListViews}, welche
durch \textit{TextViews} mit den Namen der jeweiligen Gruppen voneinander abgegrenzt werden sollten. Damit der Nutzer alle drei \textit{ListViews} durch Scrollen erreichen kann, sollten sie in einer \textit{ScrollView} angeordnet sein. Android lässt es allerdings nicht zu, zwei scrollbare Elemente ineinander zu verschachteln. Also musste die einfache Lösung, die bereits im \textit{ObligationFragment} Verwendung gefunden hat, einer komplexeren Lösung weichen. Unser nächster Ansatz war, die drei \textit{ListViews} in \textit{CardViews} zu verpacken und diese dann untereinander anzuorden. Diese Lösung war auch nicht optimal, da die \textit{ListViews} dann auf eine minimal Größe zusammengeschrumpft sind, sodass der Nutzer keine gute Ansicht der Motivationen hatte. Schließlich wurde die Idee der drei \textit{ListViews} komplett verworfen. Der frühere \textit{BaseAdapter} musste durch einen mit wesentlich höherem Implementierungsaufwand verbundenem \textit{BaseExpandableListAdapter} ersetzt werden und die drei \textit{ListViews} wurden in einer \textit{ExpandableListView} zusammengefasst.

\subsubsection{AppearanceFragment.kt}
\subsubsection{GearFragment.kt}

\subsection{Würfeltool}


\section{Test und Usability}

\section{Zusammenfassung}